CANONICAL SUBSET RECIPE
Shunyaya Symbolic Mathematical Network (SSM-NET)
Status: Public Research Release (v2.1)
Date: November 10, 2025
Caution: Research/observation only. Not for critical decision-making.

Purpose
Define how senders and receivers build the exact byte stream used for sha256=... commitment. The same byte recipe must produce the same digest everywhere.

Scope
This recipe is declared in the manifest and MUST be replayable by any receiver. Changing the recipe requires minting a new manifest_id.

1) Inputs (illustrative names; bound in manifest.canonical_subset)

ordering: stable list of field names and optional payload byte ranges, e.g. ["headerA","headerB","payload[0:256]"].

whitespace: "trim" or "preserve".

newline: "LF" (literal \n).

byte_ranges: array of {start,end} for payload slicing, e.g. [{"start":0,"end":255}].

normalization: "none" or algorithm tag if future-safe transforms are added (today: "none").

encoding: all textual items encoded as UTF-8 bytes before concatenation.

field_lookup: map telling how to extract each named item (e.g., from headers map or raw payload).

disclosure: which logical parts are declared (e.g., value+band) — published for human clarity, not used in hashing.

Token grammar (clarity helpers)

Header token: a bare name like "headerA" → look up case-exact key in the headers map.

Payload slice token: "payload[i:j]" with inclusive i and inclusive j, 0 ≤ i ≤ j.

Regex helpers (optional):

payload\[(\d+):(\d+)\]

^[A-Za-z0-9_\-]+$ for simple header keys

2) Deterministic Rules

Exact bytes only. Hash is computed over bytes, not pretty-printed strings.

Stable order. Use ordering exactly as listed. No extra fields, no reordering.

Whitespace policy. If whitespace=="trim", apply trimming before UTF-8 encoding; if "preserve", use as-is.

Newlines. Join parts with a single \n (LF) regardless of platform. Do not add a trailing newline after the last part.

Ranges. payload[i:j] means inclusive i to inclusive j over raw payload bytes.

Normalization. If "none", do nothing beyond the whitespace rule.

No implicit defaults. Every behavior above must be declared in the manifest, or the recipe is invalid.

3) Canonical Algorithm

parts := []

For each token t in ordering:
  If t is a header name (e.g., "headerA"):
    v := headers[t]              // string; case-exact key
    if whitespace == "trim": v := trim(v)
    b := UTF8(v)                 // encode exactly once
    parts.push(b)

  Else if t is a payload slice (e.g., "payload[0:256]"):
    b := payload_bytes[0:256]    // inclusive end as declared
    parts.push(b)

bytes  := JOIN_WITH("\n", parts) // byte join with a single LF; no final LF
digest := SHA256(bytes)          // 32-byte hash; when logged, use lowercase hex


4) Example (copy-ready)

ordering     : ["headerA","headerB","payload[0:256]"]
whitespace   : "trim"
newline      : "LF"
byte_ranges  : [{"start":0,"end":255}]
normalization: "none"
encoding     : "utf-8"


Example pseudocode

bytes  := JOIN_WITH_NEWLINES([ headerA, headerB, payload[0:256] ])
sha256 := SHA256(bytes)


5) Conformance Checks (recommended)

Replay test: Receiver recomputes sha256 from the packet + manifest recipe and must match the published sha256.

Order test: Swapping any two ordering items must flip the digest (guards against accidental reordering).

Range test: Changing any byte within a declared range must flip the digest.

Whitespace test: Set whitespace="trim" vs "preserve" on the same logical strings and verify expected digests differ.

LF test: Ensure \r\n vs \n sources normalize to \n at join time.

6) Error Handling

Missing field: If any ordering token cannot be resolved, verification fails with reason="missing_field".

Bad range: If a range exceeds payload bounds, verification fails with reason="range_oob".

Undeclared behavior: If a needed behavior is not in the manifest (e.g., newline policy), verification fails with reason="recipe_undefined".

7) Security / Integrity Notes

Byte commitment, not semantics. The digest binds declared bytes only; undisclosed bytes are outside this commitment.

No silent transforms. Avoid locale-dependent or platform-dependent conversions. Keep normalization="none" unless well-specified.

Auditability. Publish the recipe in the manifest so any party can verify independently.

8) Manifest Binding

manifest.canonical_subset.ordering → array of tokens.

manifest.canonical_subset.whitespace → "trim" or "preserve".

manifest.canonical_subset.newline → "LF".

manifest.canonical_subset.byte_ranges → list of {start,end} used by payload[...].

manifest.canonical_subset.normalization → today "none".

manifest.canonical_subset.encoding → "utf-8".

One-line takeaway
Commit what you promise. Publish the byte recipe. Let every receiver recompute the same sha256.